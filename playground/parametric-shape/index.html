<html>
	<head>
		<title>Awesome shit</title>
		<style>
			canvas { 
				width: 100%; 
				height: 100% 
			}
		</style>
	</head>
	<body>
		<script src="../../assets/js/three.min.js"></script>
		<script src="../../assets/js/orbitcontrols.js"></script>
		<script src="../../assets/js/dat.gui.min.js"></script>
		<script src="../../assets/js/SubdivisionModifier.js"></script>
		<script src="../../assets/js/quickhull.js"></script>
		<script src="../../assets/js/jquery-2.1.1.min.js"></script>
		<link rel="stylesheet" href="../../assets/css/style.css">
		<script>

		var viz;

		$( document )
			.ready(
				function() {

				viz = new emoVIZ();
				document.body.appendChild( viz.renderer.domElement );

				// LIGHT
				//var light = new THREE.AmbientLight( 0x404040 );
				//scene.add(light);

				//RENDER
				function render() {
					requestAnimationFrame( render ); 
					//viz.parametricCube.mesh.rotation.y += 0.01;
					//viz.parametricCube.mesh.rotation.z += 0.01;
					viz.renderer.render(viz.scene, viz.camera); 
				}

				render();

		});

		//GLOBAL STUFF
		//MATERIALS
		var  materials = {	normal: new THREE.MeshNormalMaterial(),
							test: new THREE.MeshPhongMaterial( { color: 0x000000, specular: 0xffffff, emissive: 0xff0000, ambient: 0x000000, shininess: 10, shading: THREE.SmoothShading, opacity: 0.9, transparent: true } ),
							redClay: new THREE.MeshLambertMaterial( { color: 0x666666, emissive: 0xa00000, ambient: 0x000000, shading: THREE.SmoothShading } ),
							greenGreySmooth: new THREE.MeshPhongMaterial( { ambient: 0x030303, color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.SmoothShading, transparent: true } ),
							grey: new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.SmoothShading } ),
							greenBlack: new THREE.MeshPhongMaterial({	ambient: 0x030303, 
																color: 0xdddddd, 
																specular: 0x009900, 
																shininess: 30, 								
																shading: THREE.FlatShading } ),

							wired: new THREE.MeshBasicMaterial({ 	color: 0x000000, 
													shading: THREE.FlatShading, 
													wireframe: true, 
													transparent: true } ),
						}
		var modifier = new THREE.SubdivisionModifier( 1 );
		var minAngle = 1;//IN RADIANS


		// THE MIGHTY EMOVIS METHOD
		var emoVIZ = function()
		{
			self = this;

			this.scene = new THREE.Scene();
			this.camera = new THREE.PerspectiveCamera( 75, $(window).innerWidth() / $(window).innerHeight(), 0.1, 1000);
			this.controls = new THREE.OrbitControls( this.camera );
			this.renderer = new THREE.WebGLRenderer( { antialias: true } );
			this.renderer.setSize( $(window).innerWidth(), $(window).innerHeight() );
			this.renderer.setClearColor( 0xffffff, 1 );

			this.pointLight = new THREE.DirectionalLight( 0xffffff );
			this.scene.add( this.pointLight );
			this.pointLight.position.set(0, 1, 1);

			this.camera.position.set(0, 0, 10);

			this.ratioValue = .5;
			this.scaleValue = 10;

			this.parametricCube = new ParametricCube();
			this.parametricCube.generateMesh();

			this.scene.add( this.parametricCube.mesh );

			// parameters for our shape
			this.parameters = {
				  smoothness: .5,
				  ratio :  .5, 
				  scale : .1, 
				  complexity: .5,
				  surface: .5,
				  symmetrie: 0,

				  setWireframe : function() {
				  	self.parametricCube.setWireframe();
				  }, 
				  switchMaterial : function() {
				  	self.parametricCube.switchMaterial();
				  }
			};


			this.gui = new dat.GUI();
			this.smoothness = this.gui.add(this.parameters, 'smoothness', 0, 1);
			this.ratio = this.gui.add(this.parameters, 'ratio', 0, 1);
			this.scale = this.gui.add(this.parameters, 'scale', 0, 1);
			this.complexity = this.gui.add(this.parameters, 'complexity', 0, 1);
			this.surface = this.gui.add(this.parameters, 'surface', 0, 1);
			this.symmetrie = this.gui.add(this.parameters, 'symmetrie', 0, 1);

			this.gui.add(this.parameters, 'switchMaterial');
			this.gui.add(this.parameters, 'setWireframe');
			


			self = this;
			
			// this event updates the parametriccube
			self.smoothness.onChange(
				function(value) {
					self.parametricCube.set(value);
				}
			);

			self.ratio.onChange(
				function(value) {
					self.ratioValue = value;
					self.parametricCube.mesh.scale.set(	self.scaleValue*self.ratioValue, 
														self.scaleValue*(1-self.ratioValue), 
														self.scaleValue*self.ratioValue);
				}
			);

			self.complexity.onChange(
				function(value){
					value=parseInt(value*20);
					self.parametricCube.complexity(value);
				}
			)

			self.scale.onChange(
				function(value) {
					self.scaleValue = value*20;
					self.parametricCube.mesh.scale.set(	self.scaleValue*self.ratioValue, 
														self.scaleValue*(1-self.ratioValue), 
														self.scaleValue*self.ratioValue);
				}
			);


		};

		//PARAMETRIC CUBES
		var ParametricCube = function() {
			self = this;

			// GET INNER GEOMETRY
			//  ADDS VERTICES AND FACES, 
			//  AND INITS LIST .inner 
			//  WHERE TRIPPLES (OUTER + INNER VERTEX, CENTER) ARE STORED
			//	WHICH WILL BE USED FOR SETTING EDGINBESS IN set(amount)
			this.subdivideRigid = function(geometry, value){
				for (var i=0; i<value;i++)
					geometry=this._subdivideRigid(geometry);
				return geometry;
			}
			this._subdivideRigid = function(geometry){

				//GET NEIGHBOURS
				this.smoothGeometry = geometry;
				this.smoothGeometry.computeFaceNormals()
				this.computeNeighbours();

				//INIT NEW GEOMETRY - SUCH THAT VERTICES ARE NOT MIXED UP
				var tmp = new THREE.Geometry();
				//LINK OLD VERTICES
				tmp.vertices = geometry.vertices;

				//FOR ALL old VERTICES
				var len = geometry.faces.length;
				for (var i=0;i<len;i++){
					var face = geometry.faces[i];

					/*if (face.neighbours.ab.normal.angleTo(face.normal) < minAngle &&
						face.neighbours.ac.normal.angleTo(face.normal) < minAngle &&
						face.neighbours.bc.normal.angleTo(face.normal) < minAngle){

						continue;
					}*/

					//CURRENT FACE a, b, c
					var a = face.a;
					var b = face.b;
					var c = face.c;
					var vA = geometry.vertices[a];
					var vB = geometry.vertices[b];
					var vC = geometry.vertices[c];

					//GET CENTERS	
					var ab = tmp.vertices.length;				
					var vAB = tmp.vertices.push(vA.clone().lerp(vB, .5));

					var ac = tmp.vertices.length;				
					var vAC = tmp.vertices.push(vA.clone().lerp(vC, .5));

					var bc = tmp.vertices.length;				
					var vBC = tmp.vertices.push(vB.clone().lerp(vC, .5));

						//BUILT NEW FACES
						/*
							     a 		new faces:
							     /\			a, ab, ac
							    /  \		ab, b, bc
							ab /____\ ac 	ab, bc, ac
							  /\    /\		ac, bc, c
							 /  \  /  \
						  b /____\/____\ c
						  		  bc
						*/

					tmp.faces.push(new THREE.Face3(a, ab, ac));
					tmp.faces.push(new THREE.Face3(ab, b, bc));
					tmp.faces.push(new THREE.Face3(ab, bc, ac));
					tmp.faces.push(new THREE.Face3(ac, bc, c));
				};

				tmp.mergeVertices();
				return tmp;
			}

			this.computeNeighbours = function(){
				var geometry = this.geometry;

				// GET NEIGHBOURS
				geometry.faces.forEach(function(face,i){
					face.neighbours = {};
					geometry.faces.forEach(function(_face,j){
						if (i==j){
							;
						} else if (	(face.a == _face.a || face.a == _face.b || face.a == _face.c) &&
									(face.b == _face.a || face.b == _face.b || face.b == _face.c) )
						{
							face.neighbours["ab"] = _face;
						} else if (	(face.c == _face.a || face.c == _face.b || face.c == _face.c) &&
									(face.a == _face.a || face.a == _face.b || face.a == _face.c) )
						{
							face.neighbours["ac"] = _face;
						} else if (	(face.c == _face.a || face.c == _face.b || face.c == _face.c) &&
									(face.b == _face.a || face.b == _face.b || face.b == _face.c) )
						{
							face.neighbours["bc"] = _face;
						}
					});	
				});
			}

			// SET EDGINESS
			this.set = function( amount ) {

				// JUST A HELPER, AS this.geometry SOMEHOW IS NOT 
				// KNOWN IN THE function BELOW
				if (parseInt(amount*4) > 3){
					// REMOVE CURRENT OBJECT
					viz.scene.remove(viz.scene.getObjectByName("ParametricCube"));
					this.smoothGeometry = undefined;
					this.generateMesh();
					this.geometry.verticesNeedUpdate = true;
					this.geometry.colorsNeedUpdate = true

					// ADD NEW OBJECT
					viz.scene.add(this.mesh);

				} else {
					modifier = new THREE.SubdivisionModifier( 4-parseInt(amount*4) );
					this.smoothGeometry = this.subdivideRigid(this.geometry.clone(), parseInt(amount*4));
					this.smooth();
				}
				
			};

			this.generateMesh = function () {
				if (this.smoothGeometry != undefined){
					this.smoothGeometry.computeFaceNormals();
					this.mesh = new THREE.Mesh(this.smoothGeometry, this.material);
				} else {
					this.geometry.computeFaceNormals();
					this.mesh = new THREE.Mesh(this.geometry, this.material);
				}

				if (self.scaleValue == undefined) self.scaleValue = 10;
				if (self.ratioValue == undefined) self.ratioValue = .5;

				this.mesh.scale.set(self.scaleValue*self.ratioValue, 
									self.scaleValue*(1-self.ratioValue), 
									self.scaleValue*self.ratioValue);

				this.mesh.name="ParametricCube";
			};

			this.setWireframe = function() {
				this.material = materials.wired;
				this.mesh.material = this.material;
			}

			this.currentMaterial = 1;
			this.switchMaterial = function() {
				this.currentMaterial=(this.currentMaterial+1)%Object.keys(materials).length;
				this.material = materials[Object.keys(materials)[this.currentMaterial]];
				console.log(Object.keys(materials)[this.currentMaterial]);

				if (this.mesh != undefined)
					this.mesh.material = this.material;

				if (viz != undefined) this.resetObject();
			}

			this.resetObject = function () {

				// REMOVE CURRENT OBJECT
				viz.scene.remove(viz.scene.getObjectByName("ParametricCube"));

				// BUILT NEW OBJECT
				if (this.smoothGeometry == undefined)
					this.smoothGeometry = this.geometry.clone();
				this.generateMesh();

				this.geometry.verticesNeedUpdate = true;
				this.geometry.colorsNeedUpdate = true

				// ADD NEW OBJECT
				viz.scene.add(this.mesh);
			}

			this.smooth = function () {
				// BUILT NEW OBJECT
				if (this.smoothGeometry == undefined)
					this.smoothGeometry = this.geometry.clone();

				var tmp = new THREE.Geometry();
				tmp.vertices = this.smoothGeometry.vertices;
				tmp.faces = this.smoothGeometry.faces;
				tmp.inner = this.smoothGeometry.inner;

				// MAKE IT SMOOTH	
				modifier.modify(tmp);
				this.smoothGeometry = tmp;

				this.resetObject();
			};

			this.complexity = function(value){

				if (value <= 1){
					this.geometry = new THREE.BoxGeometry(1,1,1);
				} else {
					//RANDOM POLYGON
					var polyGeometry = new THREE.Geometry(); 
					for (var i=0; i<value*10; i++){
						var v = new THREE.Vector3(	1*(Math.random()-.5),
													1*(Math.random()-.5),
													1*(Math.random()-.5));
						v.id = i;
						polyGeometry.vertices.push(v);
					}
					this.geometry = QuickHull(polyGeometry);
				}
				this.smoothGeometry = this.subdivideRigid(this.geometry.clone(), 1);

				this.mesh = this.generateMesh();
				/*this.mesh.scale.set(self.scaleValue*self.ratioValue, 
									self.scaleValue*(1-self.ratioValue), 
									self.scaleValue*self.ratioValue);*/

				if (viz != undefined) this.resetObject();
			}

			this.complexity(10);			
			//modifier.modify(this.smoothGeometry);
			this.switchMaterial();
		}


		//-----------------------------------------------
		//-----------------------------------------------
		//-----------------------------------------------
		//-----------------------------------------------
		//
		// PREVIOUS VERSION

		var ParametricCube_OLD = function() {

			self = this;

			this.geometry = new THREE.Geometry();//{ smoothed : new THREE.Geometry(), original: new THREE.Geometry() }
			this.geometrySmoothed = new THREE.Geometry();
			this.mesh = {smoothed:{}, original : {} };

				/*  vertice-index as seen from orthogonal 'above' of top, 

				1----2
				|	 |    
				|	 |   
				0----3

				vertice-index as seen from orthogonal 'above' of bottom, 

				5----6
				|	 |    
				|	 |   
				4----7

				*/

			this.outerVertices = {
				bottom : [
					// bottom
					new THREE.Vector3(0,0,0),
					new THREE.Vector3(0,0,1),
					new THREE.Vector3(1,0,1),
					new THREE.Vector3(1,0,0)
				], 
				top : [
					// top
					new THREE.Vector3(0,1,0),
					new THREE.Vector3(0,1,1),
					new THREE.Vector3(1,1,1),
					new THREE.Vector3(1,1,0)
				]
			};

			this.geometry.vertices.push( this.outerVertices.top[0] );
			this.geometry.vertices.push( this.outerVertices.top[1] );
			this.geometry.vertices.push( this.outerVertices.top[2] );
			this.geometry.vertices.push( this.outerVertices.top[3] );

			this.geometry.vertices.push( this.outerVertices.bottom[0] );
			this.geometry.vertices.push( this.outerVertices.bottom[1] );
			this.geometry.vertices.push( this.outerVertices.bottom[2] );
			this.geometry.vertices.push( this.outerVertices.bottom[3] );



			this.centroids = {
				front 	: new THREE.Vector3(0.5,0.5,0),
				back 	: new THREE.Vector3(0.5,0.5,1),
				left 	: new THREE.Vector3(0,0.5,0.5),
				right 	: new THREE.Vector3(1,0.5,0.5),
				top 	: new THREE.Vector3(0.5,1,0.5),
				bottom 	: new THREE.Vector3(0.5,0,0.5)
			};

			this.innerVertices = { front : [],  back : [],  left : [],  right : [],  top : [],  bottom : [] };

			this.innerVertices.front.push( { v : this.centroids.front.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.front[0].v ); 

			this.innerVertices.front.push( { v : this.centroids.front.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.front[1].v ); 
			this.innerVertices.front.push( { v : this.centroids.front.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.front[2].v ); 
			this.innerVertices.front.push( { v : this.centroids.front.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.front[3].v ); 

			this.innerVertices.back.push( {v : this.centroids.back.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.back[0].v );
			this.innerVertices.back.push( {v : this.centroids.back.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.back[1].v );
			this.innerVertices.back.push( {v : this.centroids.back.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.back[2].v );
			this.innerVertices.back.push( {v : this.centroids.back.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.back[3].v );

			this.innerVertices.left.push( {v : this.centroids.left.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.left[0].v );
			this.innerVertices.left.push( {v : this.centroids.left.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.left[1].v );
			this.innerVertices.left.push( {v : this.centroids.left.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.left[2].v );
			this.innerVertices.left.push( {v : this.centroids.left.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.left[3].v );

			this.innerVertices.right.push( {v : this.centroids.right.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.right[0].v );
			this.innerVertices.right.push( {v : this.centroids.right.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.right[1].v );
			this.innerVertices.right.push( {v : this.centroids.right.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.right[2].v );
			this.innerVertices.right.push( {v : this.centroids.right.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.right[3].v );

			this.innerVertices.top.push( {v : this.centroids.top.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.top[0].v );
			this.innerVertices.top.push( {v : this.centroids.top.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.top[1].v );
			this.innerVertices.top.push( {v : this.centroids.top.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.top[2].v );
			this.innerVertices.top.push( {v : this.centroids.top.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.top[3].v );

			this.innerVertices.bottom.push( {v : this.centroids.bottom.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.bottom[0].v );
			this.innerVertices.bottom.push( {v : this.centroids.bottom.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.bottom[1].v );
			this.innerVertices.bottom.push( {v : this.centroids.bottom.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.bottom[2].v );
			this.innerVertices.bottom.push( {v : this.centroids.bottom.clone(), id : this.geometry.vertices.length } ); this.geometry.vertices.push( this.innerVertices.bottom[3].v );



			/*this.geometry.faces.push( new THREE.Face3( this.innerVertices.front[0].id, this.innerVertices.front[1].id, this.innerVertices.front[2].id) );
			this.geometry.faces.push( new THREE.Face3( this.innerVertices.front[2].id, this.innerVertices.front[3].id, this.innerVertices.front[0].id) );

			this.geometry.faces.push( new THREE.Face3( 4, this.innerVertices.front[1].id, this.innerVertices.front[0].id) );
			this.geometry.faces.push( new THREE.Face3( 4, 0, this.innerVertices.front[1].id) );
			this.geometry.faces.push( new THREE.Face3( 0, this.innerVertices.front[2].id, this.innerVertices.front[1].id) );
			this.geometry.faces.push( new THREE.Face3( 0, 3, this.innerVertices.front[2].id) );
			this.geometry.faces.push( new THREE.Face3( 3, this.innerVertices.front[3].id, this.innerVertices.front[2].id) );
			this.geometry.faces.push( new THREE.Face3( 3, 7, this.innerVertices.front[3].id) );
			this.geometry.faces.push( new THREE.Face3( 7, this.innerVertices.front[0].id, this.innerVertices.front[3].id) );
			this.geometry.faces.push( new THREE.Face3( 7, 4, this.innerVertices.front[0].id) );

*/
			this.geometry.faces.push( new THREE.Face3( this.innerVertices.back[0].id, this.innerVertices.back[1].id, this.innerVertices.back[2].id) );
			this.geometry.faces.push( new THREE.Face3( this.innerVertices.back[2].id, this.innerVertices.back[3].id, this.innerVertices.back[0].id) );


			this.geometry.faces.push( new THREE.Face3( 6, this.innerVertices.back[1].id, this.innerVertices.back[0].id) );
			this.geometry.faces.push( new THREE.Face3( 6, 2, this.innerVertices.back[1].id) );
			this.geometry.faces.push( new THREE.Face3( 2, this.innerVertices.back[2].id, this.innerVertices.back[1].id) );
			this.geometry.faces.push( new THREE.Face3( 2, 1, this.innerVertices.back[2].id) );
			this.geometry.faces.push( new THREE.Face3( 1, this.innerVertices.back[3].id, this.innerVertices.back[2].id) );
			this.geometry.faces.push( new THREE.Face3( 1, 5, this.innerVertices.back[3].id) );
			this.geometry.faces.push( new THREE.Face3( 5, this.innerVertices.back[0].id, this.innerVertices.back[3].id) );
			this.geometry.faces.push( new THREE.Face3( 5, 6, this.innerVertices.back[0].id) );

/*
			this.geometry.faces.push( new THREE.Face3( this.innerVertices.top[0].id, this.innerVertices.top[1].id, this.innerVertices.top[2].id) );
			this.geometry.faces.push( new THREE.Face3( this.innerVertices.top[2].id, this.innerVertices.top[3].id, this.innerVertices.top[0].id) );

			this.geometry.faces.push( new THREE.Face3( 0, this.innerVertices.top[1].id, this.innerVertices.top[0].id) );
			this.geometry.faces.push( new THREE.Face3( 0, 1, this.innerVertices.top[1].id) );
			this.geometry.faces.push( new THREE.Face3( 1, this.innerVertices.top[2].id, this.innerVertices.top[1].id) );
			this.geometry.faces.push( new THREE.Face3( 1, 2, this.innerVertices.top[2].id) );
			this.geometry.faces.push( new THREE.Face3( 2, this.innerVertices.top[3].id, this.innerVertices.top[2].id) );
			this.geometry.faces.push( new THREE.Face3( 2, 3, this.innerVertices.top[3].id) );
			this.geometry.faces.push( new THREE.Face3( 3, this.innerVertices.top[0].id, this.innerVertices.top[3].id) );
			this.geometry.faces.push( new THREE.Face3( 3, 0, this.innerVertices.top[0].id) );



			this.geometry.faces.push( new THREE.Face3( this.innerVertices.bottom[0].id, this.innerVertices.bottom[2].id, this.innerVertices.bottom[1].id) );
			this.geometry.faces.push( new THREE.Face3( this.innerVertices.bottom[3].id, this.innerVertices.bottom[2].id, this.innerVertices.bottom[0].id) );

			//BOTTOM
			this.geometry.faces.push( new THREE.Face3( 7, this.innerVertices.bottom[2].id, this.innerVertices.bottom[3].id) );
			this.geometry.faces.push( new THREE.Face3( 7, 6, this.innerVertices.bottom[2].id) );
			this.geometry.faces.push( new THREE.Face3( 6, this.innerVertices.bottom[1].id, this.innerVertices.bottom[2].id) );
			this.geometry.faces.push( new THREE.Face3( 6, 5, this.innerVertices.bottom[1].id) );
			this.geometry.faces.push( new THREE.Face3( 5, this.innerVertices.bottom[0].id, this.innerVertices.bottom[1].id) );
			this.geometry.faces.push( new THREE.Face3( 5, 4, this.innerVertices.bottom[0].id) );
			this.geometry.faces.push( new THREE.Face3( 4, this.innerVertices.bottom[3].id, this.innerVertices.bottom[0].id) );
			this.geometry.faces.push( new THREE.Face3( 4, 7, this.innerVertices.bottom[3].id) );

			*/


/*			this.geometry.faces.push( new THREE.Face3( this.innerVertices.left[0].id, this.innerVertices.left[1].id, this.innerVertices.left[2].id) );
			this.geometry.faces.push( new THREE.Face3( this.innerVertices.left[2].id, this.innerVertices.left[3].id, this.innerVertices.left[0].id) );

			this.geometry.faces.push( new THREE.Face3( 5, this.innerVertices.left[1].id, this.innerVertices.left[0].id) );
			this.geometry.faces.push( new THREE.Face3( 5, 1, this.innerVertices.left[1].id) );
			this.geometry.faces.push( new THREE.Face3( 1, this.innerVertices.left[2].id, this.innerVertices.left[1].id) );
			this.geometry.faces.push( new THREE.Face3( 1, 0, this.innerVertices.left[2].id) );
			this.geometry.faces.push( new THREE.Face3( 0, this.innerVertices.left[3].id, this.innerVertices.left[2].id) );
			this.geometry.faces.push( new THREE.Face3( 0, 4, this.innerVertices.left[3].id) );
			this.geometry.faces.push( new THREE.Face3( 4, this.innerVertices.left[0].id, this.innerVertices.left[3].id) );
			this.geometry.faces.push( new THREE.Face3( 4, 5, this.innerVertices.left[0].id) );

			this.geometry.faces.push( new THREE.Face3( this.innerVertices.right[0].id, this.innerVertices.right[1].id, this.innerVertices.right[2].id) );
			this.geometry.faces.push( new THREE.Face3( this.innerVertices.right[2].id, this.innerVertices.right[3].id, this.innerVertices.right[0].id) );

			this.geometry.faces.push( new THREE.Face3( 7, this.innerVertices.right[1].id, this.innerVertices.right[0].id) );
			this.geometry.faces.push( new THREE.Face3( 7, 3, this.innerVertices.right[1].id) );
			this.geometry.faces.push( new THREE.Face3( 3, this.innerVertices.right[2].id, this.innerVertices.right[1].id) );
			this.geometry.faces.push( new THREE.Face3( 3, 2, this.innerVertices.right[2].id) );
			this.geometry.faces.push( new THREE.Face3( 2, this.innerVertices.right[3].id, this.innerVertices.right[2].id) );
			this.geometry.faces.push( new THREE.Face3( 2, 6, this.innerVertices.right[3].id) );
			this.geometry.faces.push( new THREE.Face3( 6, this.innerVertices.right[0].id, this.innerVertices.right[3].id) );
			this.geometry.faces.push( new THREE.Face3( 6, 7, this.innerVertices.right[0].id) );
*/

			for ( var i = 0; i < this.geometry.faces.length; i ++ ) {
				var f  = this.geometry.faces[ i ];
				for( var j = 0; j < 3; j++ ) {
					var color = new THREE.Color( 0xffffff );
					f.vertexColors.push(color);
				}

			}




			this.updateVertexColor = function() {
				var abc = "abc";
				for ( var i = 0; i < this.geometry.faces.length; i ++ ) {
					for( var j = 0; j < 3; j++ ) {
						vertexIndex = this.geometry.faces[i][ abc.charAt(j) ];
						v = this.geometry.vertices[ vertexIndex ];
						//this.geometry.faces[ i ].vertexColors[ j ].setRGB( v.x*100, v.y100, v.z*100 );
						this.geometry.verticesNeedUpdate = true;
					}
				}
			};

			// 0 = centroid, 1 = outerVertice
			this.set = function( amount ) {

				/* 
				vertice-index as seen from orthogonal 'above'
					1----2
					| \  |
					|  \ |
					0----3
				*/

				// front
				this.innerVertices.front[0].v.copy( this.centroids.front.clone().lerp( this.outerVertices.bottom[0], amount));
				this.innerVertices.front[1].v.copy( this.centroids.front.clone().lerp( this.outerVertices.top[0], amount));
				this.innerVertices.front[2].v.copy( this.centroids.front.clone().lerp( this.outerVertices.top[3], amount));
				this.innerVertices.front[3].v.copy( this.centroids.front.clone().lerp( this.outerVertices.bottom[3], amount));
				
				// back
				this.innerVertices.back[0].v.copy( this.centroids.back.clone().lerp( this.outerVertices.bottom[2], amount));
				this.innerVertices.back[1].v.copy( this.centroids.back.clone().lerp( this.outerVertices.top[2], amount));
				this.innerVertices.back[2].v.copy( this.centroids.back.clone().lerp( this.outerVertices.top[1], amount));
				this.innerVertices.back[3].v.copy( this.centroids.back.clone().lerp( this.outerVertices.bottom[1], amount));

				// left
				this.innerVertices.left[0].v.copy( this.centroids.left.clone().lerp( this.outerVertices.bottom[1], amount));
				this.innerVertices.left[1].v.copy( this.centroids.left.clone().lerp( this.outerVertices.top[1], amount));
				this.innerVertices.left[2].v.copy( this.centroids.left.clone().lerp( this.outerVertices.top[0], amount));
				this.innerVertices.left[3].v.copy( this.centroids.left.clone().lerp( this.outerVertices.bottom[0], amount));


				// right 
				this.innerVertices.right[0].v.copy( this.centroids.right.clone().lerp( this.outerVertices.bottom[3], amount));
				this.innerVertices.right[1].v.copy( this.centroids.right.clone().lerp( this.outerVertices.top[3], amount));
				this.innerVertices.right[2].v.copy( this.centroids.right.clone().lerp( this.outerVertices.top[2], amount));
				this.innerVertices.right[3].v.copy( this.centroids.right.clone().lerp( this.outerVertices.bottom[2], amount));

				// top
				this.innerVertices.top[0].v.copy( this.centroids.top.clone().lerp( this.outerVertices.top[0], amount) );
				this.innerVertices.top[1].v.copy( this.centroids.top.clone().lerp( this.outerVertices.top[1], amount) );
				this.innerVertices.top[2].v.copy( this.centroids.top.clone().lerp( this.outerVertices.top[2], amount) );
				this.innerVertices.top[3].v.copy( this.centroids.top.clone().lerp( this.outerVertices.top[3], amount) );

				// bottom
				this.innerVertices.bottom[0].v.copy( this.centroids.bottom.clone().lerp( this.outerVertices.bottom[0], amount) );
				this.innerVertices.bottom[1].v.copy( this.centroids.bottom.clone().lerp( this.outerVertices.bottom[1], amount) );
				this.innerVertices.bottom[2].v.copy( this.centroids.bottom.clone().lerp( this.outerVertices.bottom[2], amount) );
				this.innerVertices.bottom[3].v.copy( this.centroids.bottom.clone().lerp( this.outerVertices.bottom[3], amount) );

				console.log(this);
				this.generateMesh();
				//this.mesh = null;//new THREE.Mesh(this.geometry, this.material);

				this.meshmaterial = this.material;

				this.updateVertexColor();

				this.geometry.verticesNeedUpdate = true;
				this.geometry.colorsNeedUpdate = true


				//this.mesh.smoothed = new THREE.SceneUtils.createMultiMaterialObject( this.geometry, this.material);


				//this.geometry.mergeVertices();
				//this.geometry.computeFaceNormals();
				//this.geometry.computeVertexNormals();



				//this.geometrySmoothed = this.geometry.clone();

			};

			this.generateMesh = function () {
				this.mesh = new THREE.SceneUtils.createMultiMaterialObject( this.geometry, materials.normal);
			};

			this.setWireframe = function() {
				this.mesh.material = materials.wired;
			}

			this.setMaterial = function() {
				this.mesh.material = materials.normal;
			}



			this.smooth = function () {
				//this.geometrySmoothed = this.geometry.clone();
				this.modifier = new THREE.SubdivisionModifier( 1 );
				this.modifier.modify(this.geometry);
				//this.geometry.colorsNeedUpdate = true
				this.geometry.verticesNeedUpdate = true;
				//this.geometry.mergeVertices();
				//this.geometry.computeFaceNormals();
				//this.geometry.computeVertexNormals();

				//this.meshSmoothed = new THREE.Mesh( this.geometrySmoothed, this.wireframe);

			};
		};
		</script>
	</body>
</html>